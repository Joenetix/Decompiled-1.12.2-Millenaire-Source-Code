import os
import json
import glob

ASSETS = r"C:\Millenaire Revived v0\src\main\resources\assets\millenaire"
BLOCKSTATES = os.path.join(ASSETS, "blockstates")
MODELS_ITEM = os.path.join(ASSETS, "models", "item")
MODELS_BLOCK = os.path.join(ASSETS, "models", "block")

def ensure_model_item(block_name, parent_model):
    item_model_path = os.path.join(MODELS_ITEM, f"{block_name}.json")
    if not os.path.exists(item_model_path):
        print(f"Generating item model for {block_name}")
        with open(item_model_path, "w") as f:
            json.dump({
                "parent": parent_model
            }, f, indent=4)

def fix_slab_blockstate(filepath, block_name):
    with open(filepath, 'r') as f:
        try:
            data = json.load(f)
        except json.JSONDecodeError:
            print(f"Error parsing {filepath}")
            return

    variants = data.get("variants", {})
    modified = False

    # Check for overlapping generic/axis variants
    keys_to_remove = []
    has_axis = any("axis=" in k for k in variants.keys())
    
    if has_axis:
        for k in variants.keys():
            if "type=" in k and "axis=" not in k:
                # This is a generic variant colliding with axis variants
                keys_to_remove.append(k)
        
        for k in keys_to_remove:
            print(f"Removing generic variant '{k}' from {block_name} to avoid overlap with axis.")
            del variants[k]
            modified = True

    # Add type=double if missing
    # We need to guess the full block model name. Usually block_name minus "_slab".
    full_block_name = block_name.replace("_slab", "")
    full_block_model = f"millenaire:block/{full_block_name}"
    
    # Check if we should add double variants
    # If it's an oriented slab (has axis), we need double variants for each axis?
    # Or just generic double? BlockOrientedSlab support AXIS on DOUBLE?
    # BlockOrientedSlab.java: getShape -> case DOUBLE: return FULL_AABB;
    # It DOES register AXIS. So yes, we need axis variants for double too.
    
    if has_axis:
        axes = ["x", "z"] # Only X and Z for oriented slab usually (y removed)
        for axis in axes:
            double_key = f"axis={axis},type=double"
            # We also need to handle other properties like 'stable' or 'waterlogged'?
            # Usually oriented slabs in Millenaire don't have 'stable'.
            # They might have 'waterlogged'.
            
            # Helper to generate all combinations of other props
            # But simpler: scan existing keys to see what props are used.
            # OR just add minimal required.
            
            # Let's iterate existing keys to find "type=bottom" counterparts and clone them for double
            for k in list(variants.keys()):
                if f"axis={axis}" in k and "type=bottom" in k:
                    # Construct double key
                    double_k = k.replace("type=bottom", "type=double")
                    if double_k not in variants:
                        print(f"Adding {double_k} to {block_name}")
                        # For model, use full block. Rotation?
                        # axis=z usually implies y=90 rotation for the TEXTURE/MODEL?
                        # For tiles, existing bottom has y=90 for z.
                        new_variant = variants[k].copy()
                        new_variant["model"] = full_block_model
                        variants[double_k] = new_variant
                        modified = True
    else:
        # Path slabs (no axis)
        # Scan for type=bottom and create matching type=double pointing to full block
        for k in list(variants.keys()):
            if "type=bottom" in k:
                double_k = k.replace("type=bottom", "type=double")
                if double_k not in variants:
                     print(f"Adding {double_k} to {block_name}")
                     variants[double_k] = { "model": full_block_model }
                     modified = True
    
    if modified:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=4)

    # Check Item Model
    # Determine best parent. 
    # If it's a slab, usually "block/X_slab_bottom" or "block/X_bottom".
    # Inspect variants to find a "bottom" model.
    bottom_model = None
    for k, v in variants.items():
        if "type=bottom" in k:
            if isinstance(v, dict) and "model" in v:
                bottom_model = v["model"]
                break
            elif isinstance(v, list): # Multipart/Random?
                bottom_model = v[0]["model"]
                break
    
    if bottom_model:
        ensure_model_item(block_name, bottom_model)

def fix_stairs_item(block_name):
    # Stairs usually don't need blockstate fixes (generated by vanilla logic often?), 
    # but strictly need item models.
    # Parent for stairs item is usually the block model itself.
    ensure_model_item(block_name, f"millenaire:block/{block_name}")

def scan_and_fix():
    # Process all _slab.json
    slabs = glob.glob(os.path.join(BLOCKSTATES, "*_slab.json"))
    for p in slabs:
        name = os.path.basename(p).replace(".json", "")
        fix_slab_blockstate(p, name)

    # Process all stairs_*.json for items
    stairs = glob.glob(os.path.join(BLOCKSTATES, "stairs_*.json"))
    for p in stairs:
        name = os.path.basename(p).replace(".json", "")
        fix_stairs_item(name)
        
    # Process path* (non-slab) items?
    # pathdirt.json exists in blockstates. Check item.
    paths = glob.glob(os.path.join(BLOCKSTATES, "path*.json"))
    for p in paths:
        name = os.path.basename(p).replace(".json", "")
        if "slab" not in name:
            ensure_model_item(name, f"millenaire:block/{name}")

if __name__ == "__main__":
    scan_and_fix()
